using System;
using System.Drawing;
using System.Windows.Forms;
//C# - строго объектно-ориентированный язык. поэтому тут сразу идет класс. 
//вообще, тут есть класс program и в нем есть метод main. аналог int main в c++. но это если бы у нас было консольное приложение.
//поскольку у нас оконное, то в том методе main (его кстати можно посмотреть в файле program.cs) только происходит, грубо говоря, 
//переключение на оконный режим, и запуск другого главного метода - конструктора объекта mainForm, который в данном контексте 
//является аналогом int main.
namespace practice{
	public partial class MainForm : Form{//класс главной формы (форма - это любое окно, кнопка и прочее)
		//partial - частичный, т.е. где-то в другом месте может быть продолжение объявления внутренностей этого класса
		//и оно есть - в MainForm.Designer.cs
		private float Func(float x, float y) { return x-y; }//правая часть уравнения
		public MainForm(){//а вот и конструктор, то есть место, где происходит главный экшон
			InitializeComponent();//тут создается окно, на нем создается pictureBox(подокно с картинкой). если интересно - MainForm.Designer.cs
			Bitmap bmp = new Bitmap(500, 500);//выделяем память и инициализируем тот самый битмап, на котором мы будем рисовать
			//потом этот битмап мы будем отправлять для отображения в picturebox1, а его в свою очередь отобразит mainForm. сложно, но куда деваться
			Graphics g = Graphics.FromImage(bmp);//на основе битмапа создаем, если так можно выразиться, движок рисования.
			Pen pen = new Pen(Color.Black,2);//перо для рисования, чтобы в дальнейшем много раз все не прописывать
			Font font = new Font("Calibri",10,FontStyle.Bold);//и шрифт
			float a=0f,b=0.5f,h=0.05f;//исследуемый отрезок, шаг. можно без зазрения совести поменять на любые другие, но только мб текст начнет наезжать друг на друга
			int n=(int)Math.Round((b-a)/h);//количество отрезков разбиения
			float []x=new float[n+1];//точки. вот тут такое странное объявление динамического массива
			float []y=new float[n+1];
			x[0]=0;//начальное условие
			y[0]=0;
			//о координатах - тут как в графикс аш
			g.DrawLine(pen,50,25,50,475);//ось y
			g.DrawLine(pen,50,475,475,475);//ось x
			g.DrawLine(pen,50,25,55,30);//стрелочка оси y
			g.DrawLine(pen,50,25,45,30);
			g.DrawLine(pen,475,475,470,470);//стрелочка оси х
			g.DrawLine(pen,475,475,470,480);
			g.DrawString("X",font,Brushes.Black,475,470);//подписи координат
			g.DrawString("Y",font,Brushes.Black,43,10);
			for (int i=1;i<=n;i++){
				x[i]=x[i-1]+h;//увеличиваем икс
				y[i]=y[i-1]+(x[i]-x[i-1])*Func(x[i-1],y[i-1]);//считаем y по эйлеру
				g.DrawLine(pen,50+x[i-1]/(b-a)*425,475-y[i-1]*4000,50+x[i]/(b-a)*425,475-y[i]*4000);//рисуем линию от прошлой точки до новой точки
				//поскольку икс изменяется в определенных рамках, мы его делим на весь исследуемый отрезок
				//(ищем часть, которую он отхватывает) и умножаем на длину исследуемого отрезка в координатах экрана
				//а игрек просто умножаем на какой-то коэффициент
				g.DrawLine(pen,50+x[i-1]/(b-a)*425,473,50+x[i-1]/(b-a)*425,478);//ставим черточку на оси x
				g.DrawLine(pen,47,475-y[i-1]*4000,53,475-y[i-1]*4000);//ставим черточку на оси y
				g.DrawString(string.Format("{0:0.00}",x[i-1]),font,Brushes.Black,35+x[i-1]/(b-a)*425,475);//подписываем числа на осях
				g.DrawString(string.Format("{0:0.0000}",y[i-1]),font,Brushes.Black,2,465-y[i-1]*4000);
			}
			g.DrawLine(pen,47,475-y[n]*4000,53,475-y[n]*4000);//недостающая черточка на y
			g.DrawString(string.Format("{0:0.0000}",y[n]),font,Brushes.Black,2,465-y[n]*4000);//и ее подпись
			pictureBox1.Image = bmp;//просим picturebox1 показать нам картинку
			(pictureBox1.Image as Bitmap).Save("output.png",System.Drawing.Imaging.ImageFormat.Png);//и выводим картинку в файл
			//да, лол, одной строчкой
		}
		void PictureBox1Click(object sender, EventArgs e){}//это техническая фигня, без нее не работает
		void MainFormLoad(object sender, EventArgs e){}
	}
}
